From 15ac1734f90376fcd5b7d9f2636792fd41296231 Mon Sep 17 00:00:00 2001
From: Mihir Patel <patelmi@microsoft.com>
Date: Fri, 10 Mar 2023 06:52:27 +0000
Subject: [PATCH] Read ID register to find pageable bit in optoe driver

The current optoe driver looks at bit 2 for all optoe1
(dev_class as ONE_ADDR) transceivers to detect if it's pageable or not.
However, for 100G CMIS based transceivers, some platforms use it as optoe1
and not optoe3. With CMIS, the pageable bit has now changed to bit 7 for
the same register. This causes incorrect behavior when the driver checks
for pageability on 100G CMIS transceiver and hence, we need to
read the transceiver ID to see if the transceiver is CMIS based and then
find the relevant pageable bit.

Test result
Tested the changes on a switch with a 100G CMIS and non-CMIS transceiver

Signed-off-by: Mihir Patel <patelmi@microsoft.com>
---
 drivers/misc/eeprom/optoe.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/drivers/misc/eeprom/optoe.c b/drivers/misc/eeprom/optoe.c
index 62294392c..b37441999 100644
--- a/drivers/misc/eeprom/optoe.c
+++ b/drivers/misc/eeprom/optoe.c
@@ -630,7 +630,23 @@ static ssize_t optoe_page_legal(struct optoe_data *optoe,
 			return status;  /* error out (no module?) */
 
 		if (optoe->dev_class == ONE_ADDR) {
-			not_pageable = QSFP_NOT_PAGEABLE;
+			u8 idRegVal;
+
+			status = optoe_eeprom_read(optoe, client, &idRegVal,
+					OPTOE_ID_REG, 1);
+			if (status < 0)
+				return status;  /* error out (no module?) */
+
+			/*
+			 * For 100G CMIS compliant optic, if userspace has dev_class as ONE_ADDR,
+			 * the driver looks at the incorrect bit to find if it is pageable.
+			 * Below check ensures we read the appropriate bit for CMIS compliant optics
+			 * with dev_class as ONE_ADDR
+			 */
+			if (idRegVal == 0x18 || idRegVal == 0x19 || idRegVal == 0x1e)
+				not_pageable = CMIS_NOT_PAGEABLE;
+			else
+				not_pageable = QSFP_NOT_PAGEABLE;
 		} else {
 			not_pageable = CMIS_NOT_PAGEABLE;
 		}
-- 
2.25.1

