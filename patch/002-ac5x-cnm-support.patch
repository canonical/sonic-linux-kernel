Subject: Add AC5/X CnM supoort

List of commits picked from 4.14 repo:
4b53d35e11 Fixed build for BE - disabled ARM64_VHE symbol
2a39183b03 Fixed usb parameters in ac5 dts files
353e642c16 AC5X add phy support, add AC5_comexpress dts
563d377816 AC5 enable booting with RAM > 0.5G
2116f8f6dc dts/ac5: Remap addresses for mvneta
5e8f687104 modify marvell nand NFC timing set for mode 0
79de05afc0 add USB Ethernet support in defconfig
a32fedcefb usb/ehci-orion: Delete unneeded local variables
996f3afc95 CPSS-11995: Add support for PCIe with AC5
cf03350c6f usb/ehci-orion: Delete debug option max-speed-full-speed
d4bbb9e96a usb/ehci-orion: Delete AC5 USB window setting and dma offset adjustment
1f397a3569 CPSS-11949: Add support for USB serial interface
73a1b37a46 SPI support in DTS
fa84d3fd6c Add USB full-speed support
8167a2535d add nand missing layouts , add option to use ndtr predefined values
66e023f864 eMMC speed support in DTS
ac22e0b87d Add i2c support for AC5
69cbbfd149 eMMC 8 bit support in DTS
9bc751c73c enable realtek 8152 usb2eth
48e9fa2d4c fix double <<..>> in ac5.dtsi
a6d705584f dts: Add AC5 IRQ support
9ef843878f Add AC5 usb support
90a9430d48 ac5_pci
83a326d157 add ac_db.dtb to marvell dtbs list in the Makefile
47d91f7e45 ac5 mvneta

List of fixes on top of the above commits:
1. Upstream catch-up for enum mvneta_type (on top of 47d91f7e45)
2. usb/ehci-orion: Set to bit mask 64
3. arm64: dts: marvell: enable ac5 rd build
4. PCI: dwc: Map ATU address
5. Implement function onfi_async_timing_mode_to_sdr_timings

Signed-off-by: Yuval Shaia <yshaia@marvell.com>
Tested-by: Raz Adashi <raza@marvell.com>
Reviewed-by: Raz Adashi <raza@marvell.com>
---
 .../devicetree/bindings/mtd/marvell-nand.txt       |   14 +
 .../devicetree/bindings/usb/ehci-orion.txt         |    1 
 arch/arm/configs/mvebu_v7_defconfig                |    3 
 arch/arm64/boot/dts/marvell/Makefile               |    2 
 arch/arm64/boot/dts/marvell/ac5.dtsi               |  379 +++++++++++++++++++
 arch/arm64/boot/dts/marvell/ac5_comexpress.dts     |   34 ++
 arch/arm64/boot/dts/marvell/ac5_db.dts             |   38 ++
 arch/arm64/boot/dts/marvell/ac5_rd.dts             |   26 +
 arch/arm64/boot/dts/marvell/ac5x_db.dts            |   32 ++
 arch/arm64/boot/dts/marvell/armada-70x0.dtsi       |   30 ++
 drivers/mtd/nand/raw/Kconfig                       |    2 
 drivers/mtd/nand/raw/internals.h                   |    1 
 drivers/mtd/nand/raw/marvell_nand.c                |  279 +++++++++++++-
 drivers/mtd/nand/raw/nand_timings.c                |   15 +
 drivers/net/ethernet/marvell/mvneta.c              |   73 ++--
 drivers/pci/controller/dwc/pcie-armada8k.c         |  394 ++++++++++++++------
 drivers/usb/host/ehci-orion.c                      |    6 
 17 files changed, 1145 insertions(+), 184 deletions(-)
 create mode 100644 arch/arm64/boot/dts/marvell/ac5.dtsi
 create mode 100644 arch/arm64/boot/dts/marvell/ac5_comexpress.dts
 create mode 100644 arch/arm64/boot/dts/marvell/ac5_db.dts
 create mode 100644 arch/arm64/boot/dts/marvell/ac5_rd.dts
 create mode 100644 arch/arm64/boot/dts/marvell/ac5x_db.dts

diff --git a/Documentation/devicetree/bindings/mtd/marvell-nand.txt b/Documentation/devicetree/bindings/mtd/marvell-nand.txt
index a2d9a0f2b..e6dfff618 100644
--- a/Documentation/devicetree/bindings/mtd/marvell-nand.txt
+++ b/Documentation/devicetree/bindings/mtd/marvell-nand.txt
@@ -2,6 +2,7 @@ Marvell NAND Flash Controller (NFC)
 
 Required properties:
 - compatible: can be one of the following:
+    * "marvell,ac5-nand-controller"
     * "marvell,armada-8k-nand-controller"
     * "marvell,armada370-nand-controller"
     * "marvell,pxa3xx-nand-controller"
@@ -57,11 +58,20 @@ Optional properties:
   step size will shrink or grow in order to fit the required strength.
   Step sizes are not completely random for all and follow certain
   patterns described in AN-379, "Marvell SoC NFC ECC".
+- nand-timing-mode:
+  This field is relevant only if "is_marvell_timing_modes" capabilitiy
+  is supportted, then the supported modes are: 0 to "max_mode_number" 
+  (the maxmium mode the NFC can support, it is also one of the driver 
+  capabilities). it is recomannded use it for Nand devices
+  that not supports ONFI and can't read the mode from parameter page,
+  else mode will be set to 0 or according to nand_ids table. 
+  In case mode is read from parameter page but also the 
+  "nand-timing-mode" is defined in dts, than device tree definition is 
+  the one that counts.
 
 See Documentation/devicetree/bindings/mtd/nand-controller.yaml for more details on
 generic bindings.
-
-
+  
 Example:
 nand_controller: nand-controller@d0000 {
 	compatible = "marvell,armada370-nand-controller";
diff --git a/Documentation/devicetree/bindings/usb/ehci-orion.txt b/Documentation/devicetree/bindings/usb/ehci-orion.txt
index 2855bae79..ad970bfeb 100644
--- a/Documentation/devicetree/bindings/usb/ehci-orion.txt
+++ b/Documentation/devicetree/bindings/usb/ehci-orion.txt
@@ -12,6 +12,7 @@ Optional properties:
 - clocks: reference to the clock
 - phys: reference to the USB PHY
 - phy-names: name of the USB PHY, should be "usb"
+- max-speed-full-speed: Limit USB to full speed
 
 Example:
 
diff --git a/arch/arm/configs/mvebu_v7_defconfig b/arch/arm/configs/mvebu_v7_defconfig
index cddce57fe..2513ec00d 100644
--- a/arch/arm/configs/mvebu_v7_defconfig
+++ b/arch/arm/configs/mvebu_v7_defconfig
@@ -67,8 +67,11 @@ CONFIG_MVNETA=y
 CONFIG_MVPP2=y
 CONFIG_SFP=y
 CONFIG_MARVELL_PHY=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
 CONFIG_MWIFIEX=y
 CONFIG_MWIFIEX_SDIO=y
+CONFIG_USB_NET_RNDIS_WLAN=y
 CONFIG_INPUT_EVDEV=y
 CONFIG_KEYBOARD_GPIO=y
 CONFIG_SERIAL_8250=y
diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
index 0f2228c12..a69c931db 100644
--- a/arch/arm64/boot/dts/marvell/Makefile
+++ b/arch/arm64/boot/dts/marvell/Makefile
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 # Mvebu SoC Family
+dtb-$(CONFIG_ARCH_MVEBU) += ac5_db.dtb
+dtb-$(CONFIG_ARCH_MVEBU) += ac5_rd.dtb
 dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-db.dtb
 dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin.dtb
 dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin-emmc.dtb
diff --git a/arch/arm64/boot/dts/marvell/ac5.dtsi b/arch/arm64/boot/dts/marvell/ac5.dtsi
new file mode 100644
index 000000000..c0e777e3b
--- /dev/null
+++ b/arch/arm64/boot/dts/marvell/ac5.dtsi
@@ -0,0 +1,379 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree For AC5.
+ *
+ * Copyright (C) 2021 Marvell
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+/*#include <dt-bindings/phy/phy-utmi-mvebu.h>*/
+
+/ {
+	model = "Marvell AC5x board";
+	compatible = "marvell,armada3700";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		prestera_rsvd: buffer@200M {
+			compatible = "shared-dma-pool"; /* to be used as a shared pool of
+											DMA buffers for a set of devices
+											*/
+			no-map;	/* 	No one other than devices registered for that mem,
+						may use this area
+					*/
+
+			/*	addr (first 2 cells) need to be aligned with actual DMA that
+				will be allocted, therefore we choose such addr, that will
+				be aligned with many DMA sizes */
+			reg = <0x2 0x0 0x0 0x400000>;
+		};
+	};
+
+	mvDma {
+		compatible = "marvell,mv_dma";
+		memory-region = <&prestera_rsvd>;
+		status = "okay";
+	};
+
+	aliases {
+		serial0 = &uart0;
+		spiflash0 = &spiflash0;
+		ethernet0 = &eth0;
+		ethernet1 = &eth1;
+	};
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>,
+				 <GIC_PPI 8 IRQ_TYPE_LEVEL_HIGH>,
+				 <GIC_PPI 10 IRQ_TYPE_LEVEL_HIGH>,
+				 <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH>;
+		//clock-frequency = <10020>;
+		//clock-frequency = <110400>;
+		//clock-frequency = <110020>;
+		clock-frequency = <25000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_PPI 12 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		dma-ranges;
+
+		internal-regs@7f000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			/* 16M internal register @ 0x7f00_0000 */
+			ranges = <0x0 0x0 0x7f000000 0x1000000>;
+			dma-coherent;
+
+			uart0: serial@12000 {
+				compatible = "snps,dw-apb-uart";
+				reg = <0x12000 0x100>;
+				reg-shift = <2>;
+				interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
+				reg-io-width = <1>;
+				clock-frequency = <328000000>;
+				status = "okay";
+			};
+
+			mdio: mdio@20000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "marvell,orion-mdio";
+				reg = <0x22004 0x4>;
+				clocks = <&core_clock>;
+				phy0: ethernet-phy@0 {
+					reg = < 0 0 >;
+				};
+			};
+
+			i2c0: i2c@11000{
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x11000 0x20>;
+
+				clocks = <&core_clock>;
+				clock-names = "core";
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				clock-frequency=<100000>;
+				status="okay";
+			};
+
+			i2c1: i2c@11100{
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x11100 0x20>;
+
+				clocks = <&core_clock>;
+				clock-names = "core";
+				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clock-frequency=<100000>;
+				status="okay";
+			};
+		};
+
+		/* Dedicated section for devices behind 32bit controllers so we
+		   can configure specific DMA mapping for them */
+		behind-32bit-controller@7f000000 {
+			compatible = "simple-bus";
+			#address-cells = <0x2>;
+			#size-cells = <0x2>;
+			ranges = <0x0 0x0 0x0 0x7f000000 0x0 0x1000000>;
+			/* Host addresses starts at 0x2000000 */
+			dma-ranges = <0x0 0x0 0x2 0x0 0x1 0x0>;
+			dma-coherent;
+
+			eth0: ethernet@20000 {
+				compatible = "marvell,armada-ac5-neta";
+				reg = <0x0 0x20000 0x0 0x4000>;
+				interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&core_clock>;
+				status = "disabled";
+				phy-mode = "sgmii";
+			};
+
+			eth1: ethernet@24000 {
+				compatible = "marvell,armada-ac5-neta";
+				reg = <0x0 0x24000 0x0 0x4000>;
+				interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&core_clock>;
+				status = "disabled";
+				phy-mode = "sgmii";
+				fixed-link {
+					speed = <100>;
+					full-duplex;
+				};
+			};
+
+			/* A dummy entry used for chipidea phy init */
+			usb1phy: usbphy {
+				compatible = "usb-nop-xceiv";
+				#phy-cells = <0>;
+			};
+
+			/* USB0 is a host USB */
+			usb0: usb@80000 {
+				compatible = "marvell,ac5-ehci", "marvell,orion-ehci";
+				reg = <0x0 0x80000 0x0 0x500>;
+				interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+				status = "okay";
+			};
+
+			/* USB1 is a peripheral USB */
+			usb1: usb@A0000 {
+				reg = <0x0 0xA0000 0x0 0x500>;
+				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+				status = "okay";
+			};
+		};
+
+		pcie0: pcie@800a0000 {
+			compatible = "marvell,ac5-pcie", "snps,dw-pcie";
+			reg = <0 0x800a0000 0 0x20000>, <0 0x3fff0000 0 0x10000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			device_type = "pci";
+			dma-coherent;
+			bus-range = <0 0xff>;
+			/* ranges for the PCI memory and I/O regions */
+			ranges = <0x82000000 0 0x30000000 0 0x30000000 0 0xfff0000>;
+
+			interrupt-map-mask = <0 0 0 1>;
+			interrupt-map = <0 0 0 1 &gic GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+
+			interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+
+			num-lanes = <1>;
+			status = "disabled";
+
+			clocks = <&core_clock>;
+		};
+
+		core_clock: core_clock@0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <400000000>;
+		};
+
+		axi_clock: axi_clock@0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <325000000>;
+		};
+
+		spi_clock: spi_clock@0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <200000000>;
+		};
+
+		spi@805a0000 {
+			compatible = "marvell,armada-3700-spi";
+			reg = <0x0 0x805a0000 0x0 0x50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			clocks = <&spi_clock>;
+		        interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+		        num-cs = <1>;
+			status = "okay";
+
+			spiflash0: spi-flash@0 {
+				compatible = "spi-nor";
+				spi-max-frequency = <50000000>;
+				spi-tx-bus-width = <1>; /* 1-single, 2-dual, 4-quad */
+				spi-rx-bus-width = <1>; /* 1-single, 2-dual, 4-quad */
+				reg = <0>;
+
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				partition@0 {
+					label = "spi_flash_part0";
+					reg = <0x0 0x800000>;
+				};
+
+				parition@1 {
+					label = "spi_flash_part1";
+					reg = <0x800000 0x700000>;
+				};
+
+				parition@2 {
+					label = "spi_flash_part2";
+					reg = <0xF00000 0x100000>;
+				};
+			};
+		};
+
+		spi@805a8000 {
+			compatible = "marvell,armada-3700-spi";
+			reg = <0x0 0x805a8000 0x0 0x50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			clocks = <&spi_clock>;
+		        interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+		        num-cs = <1>;
+			status = "disabled";
+		};
+
+		sdhci@805c0000 {
+			compatible = "marvell, ac5-sdhci", "marvell,armada-ap806-sdhci";
+			reg = <0x0 0x805c0000 0x0 0x300>;
+			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&core_clock>;
+			clock-names = "core";
+			status = "okay";
+			bus-width = <8>;
+			//marvell,xenon-phy-slow-mode;
+			non-removable;
+			mmc-ddr-1_8v;
+			mmc-hs200-1_8v;
+			mmc-hs400-1_8v;
+		};
+
+		nand0: nand@805b00 {
+			compatible = "marvell,ac5-nand-controller";
+			reg =  <0x0 0x805b0000 0x0 0x00000054
+				0x0 0x840F8204 0x0 0x00000004
+				0x0 0x80013010 0x0 0x00000020>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&core_clock>;
+			/*marvell,system-controller = <0x15>*/
+			status = "okay";
+			nand-timing-mode = <1>;
+
+			nand@0 {
+				reg = <0x0>;
+				label = "main-storage";
+				nand-rb = <0>;
+				nand-ecc-mode = "hw";
+				nand-ecc-strength = <12>;
+				nand-ecc-step-size = <512>;
+			};
+		};
+
+		prestera {
+			compatible = "marvell,armada-ac5-switch";
+			interrupts = <GIC_SPI 0x23 IRQ_TYPE_LEVEL_HIGH>;
+			status = "okay";
+		};
+
+	};
+
+	gic: interrupt-controller@80600000 {
+		compatible = "arm,gic-v3";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		/*#redistributor-regions = <1>;*/
+		redistributor-stride = <0x0 0x20000>;	// 128kB stride
+		reg = <0x0 0x80600000 0x0 0x10000>, /* GICD */
+			  <0x0 0x80660000 0x0 0x40000>; /* GICR */
+		interrupts = <GIC_PPI 6 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&CPU0>;
+				};
+				core1 {
+					cpu = <&CPU1>;
+				};
+			};
+		};
+
+		CPU0:cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			next-level-cache = <&L2_0>;
+		};
+
+		CPU1:cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			next-level-cache = <&L2_0>;
+		};
+
+		L2_0: l2-cache0 {
+			compatible = "cache";
+		};
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x2 0x00000000 0x0 0x40000000>;
+	};
+
+};
diff --git a/arch/arm64/boot/dts/marvell/ac5_comexpress.dts b/arch/arm64/boot/dts/marvell/ac5_comexpress.dts
new file mode 100644
index 000000000..0cf91d257
--- /dev/null
+++ b/arch/arm64/boot/dts/marvell/ac5_comexpress.dts
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree For AC5 comExpress.
+ *
+ * Copyright (C) 2021 Marvell
+ *
+ */
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for Marvell AC5 comExpress development board
+ * This board file supports the B configuration of the board
+ */
+
+#include "ac5.dtsi"
+
+/ {
+	model = "Marvell AC5 COMEXPRESS board";
+};
+
+&eth0 {
+	status = "okay";
+	phy = <&phy0>;
+};
+
+&usb1 {
+	compatible = "chipidea,usb2";
+	phys = <&usb1phy>;
+	phy-names = "usb-phy";
+	dr_mode = "peripheral";
+};
+
+&nand {
+   status = "disabled";
+};
diff --git a/arch/arm64/boot/dts/marvell/ac5_db.dts b/arch/arm64/boot/dts/marvell/ac5_db.dts
new file mode 100644
index 000000000..2f85508ea
--- /dev/null
+++ b/arch/arm64/boot/dts/marvell/ac5_db.dts
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree For AC5_db.
+ *
+ * Copyright (C) 2021 Marvell
+ *
+ */
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for Marvell Alleycat 5 development board
+ * This board file supports the B configuration of the board
+ */
+
+#include "ac5.dtsi"
+
+/ {
+	model = "Marvell AC5 DB board";
+};
+
+&eth0 {
+	status = "okay";
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&eth1 {
+	status = "okay";
+};
+
+&usb1 {
+	compatible = "chipidea,usb2";
+	phys = <&usb1phy>;
+	phy-names = "usb-phy";
+	dr_mode = "peripheral";
+};
+
diff --git a/arch/arm64/boot/dts/marvell/ac5_rd.dts b/arch/arm64/boot/dts/marvell/ac5_rd.dts
new file mode 100644
index 000000000..d382178a0
--- /dev/null
+++ b/arch/arm64/boot/dts/marvell/ac5_rd.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree For AC5X.
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ */
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for Marvell Armada 7040 development board
+ * This board file supports the B configuration of the board
+ */
+
+#include "ac5.dtsi"
+
+/ {
+	model = "Marvell AC5 RD board";
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&usb1 {
+	compatible = "marvell,ac5-ehci", "marvell,orion-ehci";
+};
diff --git a/arch/arm64/boot/dts/marvell/ac5x_db.dts b/arch/arm64/boot/dts/marvell/ac5x_db.dts
new file mode 100644
index 000000000..6a5bc72d4
--- /dev/null
+++ b/arch/arm64/boot/dts/marvell/ac5x_db.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree For AC5X.
+ *
+ * Copyright (C) 2021 Marvell
+ *
+ */
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for Marvell Alleycat 5X development board
+ * This board file supports the B configuration of the board
+ */
+
+#include "ac5.dtsi"
+
+
+&eth0 {
+	status = "okay";
+	phy = <&phy0>;
+};
+
+&eth1 {
+	status = "okay";
+};
+
+&usb1 {
+	compatible = "chipidea,usb2";
+	phys = <&usb1phy>;
+	phy-names = "usb-phy";
+	dr_mode = "peripheral";
+};
+
diff --git a/arch/arm64/boot/dts/marvell/armada-70x0.dtsi b/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
index 179218774..c4fab4d03 100644
--- a/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
@@ -12,6 +12,36 @@ aliases {
 		spi1 = &cp0_spi0;
 		spi2 = &cp0_spi1;
 	};
+
+/*  Should be unmarked, when need to enlarge legacy DMA allocation */
+#ifdef NONE
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		prestera_rsvd: buffer {
+			compatible = "shared-dma-pool"; /* to be used as a shared pool of
+											DMA buffers for a set of devices
+											*/
+			no-map;	/* 	No one other than devices registered for that mem,
+						may use this area
+					*/
+
+			/*	addr (first 2 cells) need to be aligned with actual DMA that
+				will be allocted, therefore we choose such addr, that will
+				be aligned with many DMA sizes */
+			reg = <0x0 0x10000000 0x0 0x2000000>;
+		};
+	};
+
+	mvDma {
+		compatible = "marvell,mv_dma";
+		memory-region = <&prestera_rsvd>;
+		status = "okay";
+	};
+#endif
+
 };
 
 /*
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index 6c46f25b5..0290244a2 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -187,7 +187,7 @@ config MTD_NAND_MARVELL
 	  including:
 	  - PXA3xx processors (NFCv1)
 	  - 32-bit Armada platforms (XP, 37x, 38x, 39x) (NFCv2)
-	  - 64-bit Aramda platforms (7k, 8k) (NFCv2)
+	  - 64-bit Aramda platforms (7k, 8k, ac5) (NFCv2)
 
 config MTD_NAND_SLC_LPC32XX
 	tristate "NXP LPC32xx SLC NAND controller"
diff --git a/drivers/mtd/nand/raw/internals.h b/drivers/mtd/nand/raw/internals.h
index 012876e14..4e7e5f57a 100644
--- a/drivers/mtd/nand/raw/internals.h
+++ b/drivers/mtd/nand/raw/internals.h
@@ -84,6 +84,7 @@ int nand_bbm_get_next_page(struct nand_chip *chip, int page);
 int nand_markbad_bbm(struct nand_chip *chip, loff_t ofs);
 int nand_erase_nand(struct nand_chip *chip, struct erase_info *instr,
 		    int allowbbt);
+const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
 void onfi_fill_interface_config(struct nand_chip *chip,
 				struct nand_interface_config *iface,
 				enum nand_interface_type type,
diff --git a/drivers/mtd/nand/raw/marvell_nand.c b/drivers/mtd/nand/raw/marvell_nand.c
index d00c916f1..b2fd8991d 100644
--- a/drivers/mtd/nand/raw/marvell_nand.c
+++ b/drivers/mtd/nand/raw/marvell_nand.c
@@ -90,6 +90,8 @@
 #include <linux/dma/pxa-dma.h>
 #include <linux/platform_data/mtd-nand-pxa3xx.h>
 
+#include "internals.h"
+
 /* Data FIFO granularity, FIFO reads/writes must be a multiple of this length */
 #define FIFO_DEPTH		8
 #define FIFO_REP(x)		(x / sizeof(u32))
@@ -226,6 +228,20 @@
 #define XTYPE_COMMAND_DISPATCH	6
 #define XTYPE_MASK		7
 
+/* use tRP_min, tWC_min and tWP_min to distinct across timings modes */
+#define IS_TIMINGS_EQUAL(t1,t2) \
+		((t1->tRP_min == t2->tRP_min &&\
+		t1->tWC_min == t2->tWC_min &&\
+		t1->tWP_min== t2->tWP_min) ? true : false)
+
+/*  ndtr0,1 set , each set has few modes level */
+typedef enum marvell_nfc_timing_mode_set{
+	MARVELL_NFC_NDTR_SET_0, 		/*tested with ac5*/
+
+	MARVELL_NFC_NDTR_NUM_OF_SET,
+	MARVELL_NFC_NDTR_SET_NON = MARVELL_NFC_NDTR_NUM_OF_SET
+}marvell_nfc_timing_mode_set_t;
+
 /**
  * struct marvell_hw_ecc_layout - layout of Marvell ECC
  *
@@ -283,14 +299,21 @@ struct marvell_hw_ecc_layout {
 
 /* Layouts explained in AN-379_Marvell_SoC_NFC_ECC */
 static const struct marvell_hw_ecc_layout marvell_nfc_layouts[] = {
-	MARVELL_LAYOUT(  512,   512,  1,  1,  1,  512,  8,  8,  0,  0,  0),
-	MARVELL_LAYOUT( 2048,   512,  1,  1,  1, 2048, 40, 24,  0,  0,  0),
-	MARVELL_LAYOUT( 2048,   512,  4,  1,  1, 2048, 32, 30,  0,  0,  0),
-	MARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,1024,32, 30),
-	MARVELL_LAYOUT( 4096,   512,  4,  2,  2, 2048, 32, 30,  0,  0,  0),
-	MARVELL_LAYOUT( 4096,   512,  8,  5,  4, 1024,  0, 30,  0, 64, 30),
-	MARVELL_LAYOUT( 8192,   512,  4,  4,  4, 2048,  0, 30,  0,  0,  0),
-	MARVELL_LAYOUT( 8192,   512,  8,  9,  8, 1024,  0, 30,  0, 160, 30),
+	MARVELL_LAYOUT(  512,   512,  1,  1,  1,  512,  8,  8,  0,   0,  0),
+	MARVELL_LAYOUT( 2048,   512,  1,  1,  1, 2048, 40, 24,  0,   0,  0),
+	MARVELL_LAYOUT( 2048,   512,  4,  1,  1, 2048, 32, 30,  0,   0,  0),
+	MARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,  1024,32, 30),
+	MARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,  1024,64, 30),
+	MARVELL_LAYOUT( 2048,   512,  12, 3,  2, 704,   0, 30,  640, 0,  30),
+	MARVELL_LAYOUT( 2048,   512,  16, 5,  4, 512,   0, 30,  0,   32, 30),
+	MARVELL_LAYOUT( 4096,   512,  4,  2,  2, 2048, 32, 30,  0,   0,  0),
+	MARVELL_LAYOUT( 4096,   512,  8,  5,  4, 1024,  0, 30,  0,   64, 30),
+	MARVELL_LAYOUT( 4096,   512,  12, 6,  5, 704,   0, 30,  576, 32, 30),
+	MARVELL_LAYOUT( 4096,   512,  16, 9,  8, 512,   0, 30,  0,   32, 30),
+	MARVELL_LAYOUT( 8192,   512,  4,  4,  4, 2048,  0, 30,  0,   0,  0),
+	MARVELL_LAYOUT( 8192,   512,  8,  9,  8, 1024,  0, 30,  0,  160, 30),
+	MARVELL_LAYOUT( 8192,   512,  12, 12, 11, 704,  0, 30,  448, 64, 30),
+	MARVELL_LAYOUT( 8192,   512,  16, 17, 16, 512,  0, 30,  0,   32, 30),
 };
 
 /**
@@ -328,6 +351,7 @@ struct marvell_nand_chip_sel {
  * @selected_die:	Current active CS
  * @nsels:		Number of CS lines required by the NAND chip
  * @sels:		Array of CS lines descriptions
+ * @nand_timing_mode:	nand-timing-mode from dts
  */
 struct marvell_nand_chip {
 	struct nand_chip chip;
@@ -339,7 +363,8 @@ struct marvell_nand_chip {
 	int addr_cyc;
 	int selected_die;
 	unsigned int nsels;
-	struct marvell_nand_chip_sel sels[];
+	struct marvell_nand_chip_sel sels[0];
+	int nand_timing_mode;
 };
 
 static inline struct marvell_nand_chip *to_marvell_nand(struct nand_chip *chip)
@@ -367,6 +392,10 @@ static inline struct marvell_nand_chip_sel *to_nand_sel(struct marvell_nand_chip
  *			BCH error detection and correction algorithm,
  *			NDCB3 register has been added
  * @use_dma:		Use dma for data transfers
+ * @is_marvell_timing_modes: use marvell predefined register values per mode
+ * @max_mode_number: supported mode by NFC (max mode that supported)
+ * @timing_mode_set: which set to use from predefined array of sets
+ 					 each set has few modes
  */
 struct marvell_nfc_caps {
 	unsigned int max_cs_nb;
@@ -375,6 +404,9 @@ struct marvell_nfc_caps {
 	bool legacy_of_bindings;
 	bool is_nfcv2;
 	bool use_dma;
+	bool is_marvell_timing_modes;
+	unsigned int max_mode_number;
+	marvell_nfc_timing_mode_set_t timing_mode_set;
 };
 
 /**
@@ -485,6 +517,119 @@ struct marvell_nfc_op {
 	const struct nand_op_instr *data_instr;
 };
 
+/* NFC ndtr0 */
+typedef union  marvell_nand_ndtr0
+{
+	struct {
+		unsigned  int tRP                 :3;  /* 0-2   */
+		unsigned  int tRH                 :3;  /* 3-5   */
+		unsigned  int tRPE                :1;  /* 6     */
+		unsigned  int tRE_edge            :1;  /* 7     */
+		unsigned  int tWP                 :3;  /* 8-10  */
+		unsigned  int tWH                 :3;  /* 11-13 */
+		unsigned  int reserved            :2;  /* 14-15 */
+		unsigned  int tCS                 :3;  /* 16-18 */
+		unsigned  int tCH                 :3;  /* 19-21 */
+		unsigned  int Rd_Cnt_Del          :4;  /* 22-25 */
+		unsigned  int selCnrl             :1;  /* 26    */
+		unsigned  int tADL                :5;  /* 27-31 */
+	} fields;
+	unsigned  int  regValue;
+}marvell_nfc_ndtr0_t;
+
+/* NFC ndtr1 */
+typedef union  marvell_nand_ndtr1
+{
+	struct {
+		unsigned  int tAR                 :4;  /* 0-3   */
+		unsigned  int tWHR                :4;  /* 4-7   */
+		unsigned  int tRHW                :2;  /* 8-9   */
+		unsigned  int reserved            :4;  /* 10-13 */
+		unsigned  int Prescale            :1;  /* 14    */
+		unsigned  int wait_mode           :1;  /* 15    */
+		unsigned  int tR                  :16; /* 16-31 */
+	} fields;
+	unsigned  int  regValue;
+}marvell_nfc_ndtr1_t;
+
+#define NUM_OF_TIMING_MODES	6
+
+/* arrays of NFC timings modes */
+typedef marvell_nfc_ndtr0_t marvell_nfc_ndtr0_arr[NUM_OF_TIMING_MODES];
+typedef marvell_nfc_ndtr1_t marvell_nfc_ndtr1_arr[NUM_OF_TIMING_MODES];
+
+#define MARVELL_NTDR0(trp, trh, trpe, tre_edge, twp, twh, resrv, tcs, tch, rd_cnt_del, selcnrl, tadl)	\
+		{\
+			.fields = {\
+				.tRP = trp,                 /* 0-2   */\
+				.tRH = trh,                 /* 3-5   */\
+				.tRPE = trpe,               /* 6     */\
+				.tRE_edge = tre_edge,       /* 7     */\
+				.tWP = twp,                 /* 8-10  */\
+				.tWH = twh,                 /* 11-13 */\
+				.reserved = resrv,          /* 14-15 */\
+				.tCS = tcs,                 /* 16-18 */\
+				.tCH = tch,                 /* 19-21 */\
+				.Rd_Cnt_Del = rd_cnt_del,   /* 22-25 */\
+				.selCnrl = selcnrl,         /* 26    */\
+				.tADL = tadl,               /* 27-31 */\
+			}\
+		}
+
+#define MARVELL_NTDR1(tar, twhr, trhw, resrv, prescale, waiting_mode, tr)	\
+		{\
+			.fields = {\
+				.tAR = tar,                 /* 0-3   */\
+				.tWHR = twhr,               /* 4-7   */\
+				.tRHW = trhw,               /* 8-9   */\
+				.reserved = resrv,          /* 10-13 */\
+				.Prescale = prescale,       /* 14    */\
+				.wait_mode = waiting_mode,  /* 15    */\
+				.tR = tr,                   /* 16-31 */\
+			}\
+		}
+
+/* ndtr0_modes and ndtr1_modes are arrays of modes with optimal values
+ * that were tested with Marvell NFC with correlation to ONFI timings mode
+ * each entry in the array presents different set of modes , for example ac5
+ * is entry 0 */
+/* todo: add more modes ASAP */
+
+/* Layouts explained in AN-379_Marvell_SoC_NFC_ECC */
+marvell_nfc_ndtr0_arr ndtr0_modes[MARVELL_NFC_NDTR_NUM_OF_SET] =
+{
+	/* value tested with AC5 */
+	{
+		MARVELL_NTDR0(7,7,1,0,7,7,0,7,7,0,1,31),
+		MARVELL_NTDR0(6,3,0,0,4,4,0,7,7,1,1,15),
+		MARVELL_NTDR0(4,3,0,0,3,3,0,7,7,2,1,15),
+		MARVELL_NTDR0(2,2,0,0,2,1,0,1,0,2,1,15)
+	}
+};
+
+marvell_nfc_ndtr1_arr ndtr1_modes[MARVELL_NFC_NDTR_NUM_OF_SET] =
+{
+	/* value tested with AC5 */
+	{
+		MARVELL_NTDR1(15,15,3,0,0,1,50),
+		MARVELL_NTDR1(15,15,3,0,0,1,25),
+		MARVELL_NTDR1(15,15,3,0,0,1,25),
+		MARVELL_NTDR1(11,11,2,0,0,1,25)
+	}
+};
+
+/*
+ * get nand timing-mode from device tree
+ */
+static int get_nand_timing_mode(struct device_node *np)
+{
+	int ret;
+	u32 val;
+
+	ret = of_property_read_u32(np, "nand-timing-mode", &val);
+	return ret ? ret : val;
+}
+
 /*
  * Internal helper to conditionnally apply a delay (from the above structure,
  * most of the time).
@@ -2254,6 +2399,14 @@ static int marvell_nand_hw_ecc_controller_init(struct mtd_info *mtd,
 	ecc->steps = l->nchunks;
 	ecc->size = l->data_bytes;
 
+	/* nand_scan_tail func perform  validity tests for ECC strength, and it
+	 * assumes that all chunks are with same size. in our case when ecc is 12
+	 * the chunk size is 704 but the last chunk is with different size so
+	 * we cheat it nand_scan_tail validity tests by set info->ecc_size value to
+	 * 512*/
+	if(ecc->strength == 12)
+		ecc->size = 512;
+
 	if (ecc->strength == 1) {
 		chip->ecc.algo = NAND_ECC_ALGO_HAMMING;
 		ecc->read_page_raw = marvell_nfc_hw_ecc_hmg_read_page_raw;
@@ -2354,9 +2507,11 @@ static int marvell_nfc_setup_interface(struct nand_chip *chip, int chipnr,
 	struct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);
 	struct marvell_nfc *nfc = to_marvell_nfc(chip->controller);
 	unsigned int period_ns = 1000000000 / clk_get_rate(nfc->core_clk) * 2;
-	const struct nand_sdr_timings *sdr;
+	const struct nand_sdr_timings *sdr,*timings;
 	struct marvell_nfc_timings nfc_tmg;
 	int read_delay;
+	marvell_nfc_timing_mode_set_t modes_set;
+	int mode = 0;
 
 	sdr = nand_get_sdr_timings(conf);
 	if (IS_ERR(sdr))
@@ -2415,32 +2570,74 @@ static int marvell_nfc_setup_interface(struct nand_chip *chip, int chipnr,
 			nfc_tmg.tR = 0;
 	}
 
-	if (chipnr < 0)
-		return 0;
+		
+	/* get the timing modes from predefined values according to its compatibility*/
+	if (nfc->caps->is_marvell_timing_modes) {
+		/* get the mode set */
+		modes_set = nfc->caps->timing_mode_set;
+		if (modes_set >= MARVELL_NFC_NDTR_SET_NON)
+		{
+			dev_warn(nfc->dev,
+				"Warning: not supported timing registers set,use set number 0 by default\n");
 
-	marvell_nand->ndtr0 =
-		NDTR0_TRP(nfc_tmg.tRP) |
-		NDTR0_TRH(nfc_tmg.tRH) |
-		NDTR0_ETRP(nfc_tmg.tRP) |
-		NDTR0_TWP(nfc_tmg.tWP) |
-		NDTR0_TWH(nfc_tmg.tWH) |
-		NDTR0_TCS(nfc_tmg.tCS) |
-		NDTR0_TCH(nfc_tmg.tCH);
+			modes_set = MARVELL_NFC_NDTR_SET_0;
+		}
 
-	marvell_nand->ndtr1 =
-		NDTR1_TAR(nfc_tmg.tAR) |
-		NDTR1_TWHR(nfc_tmg.tWHR) |
-		NDTR1_TR(nfc_tmg.tR);
+		/* find the caller mode according to timings values */
+		/* if exit on error it means no more modes; not suppose to happen*/
+		do
+		{
+			timings = onfi_async_timing_mode_to_sdr_timings(mode);
+			if( IS_TIMINGS_EQUAL(timings,sdr))
+				break;
+			mode++;
+		}while(!IS_ERR(timings));
+
+		/* if mode is not supported by NFC, return false or if nand-timing-mode that
+		 * exists in device tree greater then caller mode also return false and wait
+		 * for caller to try with next mode (mode-1). we want the nand feature to be
+		 * configured with nand-timing-mode value */
+		if ( mode > nfc->caps->max_mode_number ||
+			 ((marvell_nand->nand_timing_mode) >= 0 &&
+			 (mode > marvell_nand->nand_timing_mode) ))
+			return -ENOTSUPP;
 
-	if (nfc->caps->is_nfcv2) {
-		marvell_nand->ndtr0 |=
-			NDTR0_RD_CNT_DEL(read_delay) |
-			NDTR0_SELCNTR |
-			NDTR0_TADL(nfc_tmg.tADL);
+		/* just checking NFC capabilities no need to set the registers */
+		if (chipnr < 0)
+			return 0;
+
+		marvell_nand->ndtr0 = ndtr0_modes[modes_set][mode].regValue;
+		marvell_nand->ndtr1 = ndtr1_modes[modes_set][mode].regValue;
+	}
+	else
+	{
+		if (chipnr < 0)
+			return 0;
 
-		marvell_nand->ndtr1 |=
-			NDTR1_TRHW(nfc_tmg.tRHW) |
-			NDTR1_WAIT_MODE;
+		marvell_nand->ndtr0 =
+			NDTR0_TRP(nfc_tmg.tRP) |
+			NDTR0_TRH(nfc_tmg.tRH) |
+			NDTR0_ETRP(nfc_tmg.tRP) |
+			NDTR0_TWP(nfc_tmg.tWP) |
+			NDTR0_TWH(nfc_tmg.tWH) |
+			NDTR0_TCS(nfc_tmg.tCS) |
+			NDTR0_TCH(nfc_tmg.tCH);
+
+		marvell_nand->ndtr1 =
+			NDTR1_TAR(nfc_tmg.tAR) |
+			NDTR1_TWHR(nfc_tmg.tWHR) |
+			NDTR1_TR(nfc_tmg.tR);
+
+		if (nfc->caps->is_nfcv2) {
+			marvell_nand->ndtr0 |=
+				NDTR0_RD_CNT_DEL(read_delay) |
+				NDTR0_SELCNTR |
+				NDTR0_TADL(nfc_tmg.tADL);
+
+			marvell_nand->ndtr1 |=
+				NDTR1_TRHW(nfc_tmg.tRHW) |
+				NDTR1_WAIT_MODE;
+		}
 	}
 
 	return 0;
@@ -2562,6 +2759,7 @@ static int marvell_nand_chip_init(struct device *dev, struct marvell_nfc *nfc,
 	struct nand_chip *chip;
 	int nsels, ret, i;
 	u32 cs, rb;
+	struct device_node *dn;
 
 	/*
 	 * The legacy "num-cs" property indicates the number of CS on the only
@@ -2675,6 +2873,10 @@ static int marvell_nand_chip_init(struct device *dev, struct marvell_nfc *nfc,
 	if (!of_property_read_bool(np, "marvell,nand-keep-config"))
 		chip->options |= NAND_KEEP_TIMINGS;
 
+	/* read the mode from device tree */
+	dn = nand_get_flash_node(chip);
+	marvell_nand->nand_timing_mode = get_nand_timing_mode(dn);
+
 	mtd = nand_to_mtd(chip);
 	mtd->dev.parent = dev;
 
@@ -3064,6 +3266,15 @@ static const struct marvell_nfc_caps marvell_armada_8k_nfc_caps = {
 	.is_nfcv2 = true,
 };
 
+static const struct marvell_nfc_caps marvell_ac5_caps = {
+	.max_cs_nb = 2,
+	.max_rb_nb = 1,
+	.is_nfcv2 = true,
+	.is_marvell_timing_modes = true,
+	.max_mode_number = 3,
+	.timing_mode_set = MARVELL_NFC_NDTR_SET_0,
+};
+
 static const struct marvell_nfc_caps marvell_armada370_nfc_caps = {
 	.max_cs_nb = 4,
 	.max_rb_nb = 2,
@@ -3112,6 +3323,10 @@ static const struct of_device_id marvell_nfc_of_ids[] = {
 		.compatible = "marvell,armada-8k-nand-controller",
 		.data = &marvell_armada_8k_nfc_caps,
 	},
+	{
+		.compatible = "marvell,ac5-nand-controller",
+		.data = &marvell_ac5_caps,
+	},
 	{
 		.compatible = "marvell,armada370-nand-controller",
 		.data = &marvell_armada370_nfc_caps,
diff --git a/drivers/mtd/nand/raw/nand_timings.c b/drivers/mtd/nand/raw/nand_timings.c
index 481b56d5f..1f825f117 100644
--- a/drivers/mtd/nand/raw/nand_timings.c
+++ b/drivers/mtd/nand/raw/nand_timings.c
@@ -600,6 +600,21 @@ onfi_find_closest_sdr_mode(const struct nand_sdr_timings *spec_timings)
 	return 0;
 }
 
+/**
+ * onfi_async_timing_mode_to_sdr_timings - [NAND Interface] Retrieve NAND
+ * timings according to the given ONFI timing mode
+ * @mode: ONFI timing mode
+ */
+const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode)
+{
+   if (mode < 0 || mode >= ARRAY_SIZE(onfi_sdr_timings))
+       return ERR_PTR(-EINVAL);
+
+   return &onfi_sdr_timings[mode].timings.sdr;
+}
+EXPORT_SYMBOL(onfi_async_timing_mode_to_sdr_timings);
+
+
 /**
  * onfi_fill_interface_config - Initialize an interface config from a given
  *                              ONFI mode
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 74e266c0b..0f5264cfb 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -39,6 +39,7 @@
 #include <net/tso.h>
 #include <net/page_pool.h>
 #include <linux/bpf_trace.h>
+#include <linux/of_reserved_mem.h>
 
 /* Registers */
 #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
@@ -353,6 +354,13 @@ enum {
 	ETHTOOL_MAX_STATS,
 };
 
+enum mvneta_type {
+	MVNETA_TYPE_XP,
+	MVNETA_TYPE_370,
+	MVNETA_TYPE_3700,
+	MVNETA_TYPE_AC5
+};
+
 struct mvneta_statistic {
 	unsigned short offset;
 	unsigned short type;
@@ -512,7 +520,7 @@ struct mvneta_port {
 	u32 indir[MVNETA_RSS_LU_TABLE_SIZE];
 
 	/* Flags for special SoC configurations */
-	bool neta_armada3700;
+	enum mvneta_type neta_type;
 	u16 rx_offset_correction;
 	const struct mbus_dram_target_info *dram_target_info;
 };
@@ -1117,7 +1125,7 @@ static int mvneta_bm_port_init(struct platform_device *pdev,
 	struct device_node *dn = pdev->dev.of_node;
 	u32 long_pool_id, short_pool_id;
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		int ret;
 
 		ret = mvneta_bm_port_mbus_init(pp);
@@ -1456,7 +1464,7 @@ static void mvneta_defaults_set(struct mvneta_port *pp)
 	for_each_present_cpu(cpu) {
 		int rxq_map = 0, txq_map = 0;
 		int rxq, txq;
-		if (!pp->neta_armada3700) {
+		if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 			for (rxq = 0; rxq < rxq_number; rxq++)
 				if ((rxq % max_cpu) == cpu)
 					rxq_map |= MVNETA_CPU_RXQ_ACCESS(rxq);
@@ -3157,8 +3165,10 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
 	/* For the case where the last mvneta_poll did not process all
 	 * RX packets
 	 */
-	cause_rx_tx |= pp->neta_armada3700 ? pp->cause_rx_tx :
-		port->cause_rx_tx;
+	if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5))
+		cause_rx_tx |= pp->cause_rx_tx;
+	else
+		cause_rx_tx |= port->cause_rx_tx;
 
 	rx_queue = fls(((cause_rx_tx >> 8) & 0xff));
 	if (rx_queue) {
@@ -3175,7 +3185,7 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
 		cause_rx_tx = 0;
 		napi_complete_done(napi, rx_done);
 
-		if (pp->neta_armada3700) {
+		if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5)) {
 			unsigned long flags;
 
 			local_irq_save(flags);
@@ -3189,7 +3199,7 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
 		}
 	}
 
-	if (pp->neta_armada3700)
+	if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5))
 		pp->cause_rx_tx = cause_rx_tx;
 	else
 		port->cause_rx_tx = cause_rx_tx;
@@ -3409,7 +3419,7 @@ static int mvneta_txq_sw_init(struct mvneta_port *pp,
 		return -ENOMEM;
 
 	/* Setup XPS mapping */
-	if (pp->neta_armada3700)
+	if (pp->neta_type == MVNETA_TYPE_3700)
 		cpu = 0;
 	else if (txq_number > 1)
 		cpu = txq->id % num_present_cpus();
@@ -3611,7 +3621,7 @@ static void mvneta_start_dev(struct mvneta_port *pp)
 	/* start the Rx/Tx activity */
 	mvneta_port_enable(pp);
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		/* Enable polling on the port */
 		for_each_online_cpu(cpu) {
 			struct mvneta_pcpu_port *port =
@@ -3651,7 +3661,7 @@ static void mvneta_stop_dev(struct mvneta_port *pp)
 
 	phylink_stop(pp->phylink);
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		for_each_online_cpu(cpu) {
 			struct mvneta_pcpu_port *port =
 				per_cpu_ptr(pp->ports, cpu);
@@ -4192,7 +4202,7 @@ static int mvneta_cpu_online(unsigned int cpu, struct hlist_node *node)
 	/* Armada 3700's per-cpu interrupt for mvneta is broken, all interrupts
 	 * are routed to CPU 0, so we don't need all the cpu-hotplug support
 	 */
-	if (pp->neta_armada3700)
+	if (pp->neta_type == MVNETA_TYPE_3700)
 		return 0;
 
 	spin_lock(&pp->lock);
@@ -4301,7 +4311,7 @@ static int mvneta_open(struct net_device *dev)
 		goto err_cleanup_rxqs;
 
 	/* Connect to port interrupt line */
-	if (pp->neta_armada3700)
+	if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5))
 		ret = request_irq(pp->dev->irq, mvneta_isr, 0,
 				  dev->name, pp);
 	else
@@ -4312,7 +4322,7 @@ static int mvneta_open(struct net_device *dev)
 		goto err_cleanup_txqs;
 	}
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		/* Enable per-CPU interrupt on all the CPU to handle our RX
 		 * queue interrupts
 		 */
@@ -4344,15 +4354,15 @@ static int mvneta_open(struct net_device *dev)
 	return 0;
 
 err_free_dead_hp:
-	if (!pp->neta_armada3700)
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5))
 		cpuhp_state_remove_instance_nocalls(CPUHP_NET_MVNETA_DEAD,
 						    &pp->node_dead);
 err_free_online_hp:
-	if (!pp->neta_armada3700)
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5))
 		cpuhp_state_remove_instance_nocalls(online_hpstate,
 						    &pp->node_online);
 err_free_irq:
-	if (pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		free_irq(pp->dev->irq, pp);
 	} else {
 		on_each_cpu(mvneta_percpu_disable, pp, true);
@@ -4370,7 +4380,7 @@ static int mvneta_stop(struct net_device *dev)
 {
 	struct mvneta_port *pp = netdev_priv(dev);
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		/* Inform that we are stopping so we don't want to setup the
 		 * driver for new CPUs in the notifiers. The code of the
 		 * notifier for CPU online is protected by the same spinlock,
@@ -4753,7 +4763,7 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
 
 	on_each_cpu(mvneta_percpu_mask_interrupt, pp, true);
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		/* We have to synchronise on the napi of each CPU */
 		for_each_online_cpu(cpu) {
 			struct mvneta_pcpu_port *pcpu_port =
@@ -4781,7 +4791,7 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
 	mvneta_percpu_elect(pp);
 	spin_unlock(&pp->lock);
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		/* We have to synchronise on the napi of each CPU */
 		for_each_online_cpu(cpu) {
 			struct mvneta_pcpu_port *pcpu_port =
@@ -4804,7 +4814,7 @@ static int mvneta_ethtool_set_rxfh(struct net_device *dev, const u32 *indir,
 	struct mvneta_port *pp = netdev_priv(dev);
 
 	/* Current code for Armada 3700 doesn't support RSS features yet */
-	if (pp->neta_armada3700)
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5))
 		return -EOPNOTSUPP;
 
 	/* We require at least one supported parameter to be changed
@@ -4828,7 +4838,7 @@ static int mvneta_ethtool_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
 	struct mvneta_port *pp = netdev_priv(dev);
 
 	/* Current code for Armada 3700 doesn't support RSS features yet */
-	if (pp->neta_armada3700)
+	if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5))
 		return -EOPNOTSUPP;
 
 	if (hfunc)
@@ -5122,7 +5132,11 @@ static int mvneta_probe(struct platform_device *pdev)
 
 	/* Get special SoC configurations */
 	if (of_device_is_compatible(dn, "marvell,armada-3700-neta"))
-		pp->neta_armada3700 = true;
+		pp->neta_type = MVNETA_TYPE_3700;
+	else if (of_device_is_compatible(dn, "marvell,armada-ac5-neta"))
+		pp->neta_type = MVNETA_TYPE_AC5;
+	else
+		pp->neta_type = MVNETA_TYPE_XP;
 
 	pp->clk = devm_clk_get(&pdev->dev, "core");
 	if (IS_ERR(pp->clk))
@@ -5188,13 +5202,12 @@ static int mvneta_probe(struct platform_device *pdev)
 	}
 
 	pp->tx_csum_limit = tx_csum_limit;
-
 	pp->dram_target_info = mv_mbus_dram_info();
 	/* Armada3700 requires setting default configuration of Mbus
 	 * windows, however without using filled mbus_dram_target_info
 	 * structure.
 	 */
-	if (pp->dram_target_info || pp->neta_armada3700)
+	if (pp->dram_target_info || (pp->neta_type == MVNETA_TYPE_3700))
 		mvneta_conf_mbus_windows(pp, pp->dram_target_info);
 
 	pp->tx_ring_size = MVNETA_MAX_TXD;
@@ -5245,8 +5258,9 @@ static int mvneta_probe(struct platform_device *pdev)
 	/* Armada3700 network controller does not support per-cpu
 	 * operation, so only single NAPI should be initialized.
 	 */
-	if (pp->neta_armada3700) {
-		netif_napi_add(dev, &pp->napi, mvneta_poll, NAPI_POLL_WEIGHT);
+	if ((pp->neta_type == MVNETA_TYPE_3700) || (pp->neta_type == MVNETA_TYPE_AC5)) {
+			netif_napi_add(dev, &pp->napi, mvneta_poll,
+				       NAPI_POLL_WEIGHT);
 	} else {
 		for_each_present_cpu(cpu) {
 			struct mvneta_pcpu_port *port =
@@ -5338,7 +5352,7 @@ static int mvneta_suspend(struct device *device)
 	if (!netif_running(dev))
 		goto clean_exit;
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		spin_lock(&pp->lock);
 		pp->is_stopped = true;
 		spin_unlock(&pp->lock);
@@ -5383,7 +5397,7 @@ static int mvneta_resume(struct device *device)
 	clk_prepare_enable(pp->clk);
 	if (!IS_ERR(pp->clk_bus))
 		clk_prepare_enable(pp->clk_bus);
-	if (pp->dram_target_info || pp->neta_armada3700)
+	if (pp->dram_target_info || (pp->neta_type == MVNETA_TYPE_3700))
 		mvneta_conf_mbus_windows(pp, pp->dram_target_info);
 	if (pp->bm_priv) {
 		err = mvneta_bm_port_init(pdev, pp);
@@ -5419,7 +5433,7 @@ static int mvneta_resume(struct device *device)
 		mvneta_txq_hw_init(pp, txq);
 	}
 
-	if (!pp->neta_armada3700) {
+	if ((pp->neta_type != MVNETA_TYPE_3700) && (pp->neta_type != MVNETA_TYPE_AC5)) {
 		spin_lock(&pp->lock);
 		pp->is_stopped = false;
 		spin_unlock(&pp->lock);
@@ -5444,6 +5458,7 @@ static const struct of_device_id mvneta_match[] = {
 	{ .compatible = "marvell,armada-370-neta" },
 	{ .compatible = "marvell,armada-xp-neta" },
 	{ .compatible = "marvell,armada-3700-neta" },
+	{ .compatible = "marvell,armada-ac5-neta" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, mvneta_match);
diff --git a/drivers/pci/controller/dwc/pcie-armada8k.c b/drivers/pci/controller/dwc/pcie-armada8k.c
index 13901f359..6f9d57153 100644
--- a/drivers/pci/controller/dwc/pcie-armada8k.c
+++ b/drivers/pci/controller/dwc/pcie-armada8k.c
@@ -24,15 +24,21 @@
 #include <linux/of_irq.h>
 
 #include "pcie-designware.h"
+#include <linux/of_gpio.h>
 
-#define ARMADA8K_PCIE_MAX_LANES PCIE_LNK_X4
-
+enum mvpcie_type {
+	MVPCIE_TYPE_A8K,
+	MVPCIE_TYPE_AC5
+};
 struct armada8k_pcie {
+#define MV_A8K_PCIE_MAX_WIDTH 4
 	struct dw_pcie *pci;
 	struct clk *clk;
-	struct clk *clk_reg;
-	struct phy *phy[ARMADA8K_PCIE_MAX_LANES];
-	unsigned int phy_count;
+	struct gpio_desc    *reset_gpio;
+	enum of_gpio_flags  flags;
+	int phy_count;
+	enum mvpcie_type pcie_type;
+	struct phy *comphy[MV_A8K_PCIE_MAX_WIDTH];
 };
 
 #define PCIE_VENDOR_REGS_OFFSET		0x8000
@@ -54,12 +60,20 @@ struct armada8k_pcie {
 #define PCIE_INT_C_ASSERT_MASK		BIT(11)
 #define PCIE_INT_D_ASSERT_MASK		BIT(12)
 
+#define PCIE_GLOBAL_INT_CAUSE2_REG	(PCIE_VENDOR_REGS_OFFSET + 0x24)
+#define PCIE_GLOBAL_INT_MASK2_REG	(PCIE_VENDOR_REGS_OFFSET + 0x28)
+#define PCIE_INT2_PHY_RST_LINK_DOWN	BIT(1)
+#define PCIE_INT_A_ASSERT_MASK_AC5	BIT(12)
+#define PCIE_INT_B_ASSERT_MASK_AC5	BIT(13)
+#define PCIE_INT_C_ASSERT_MASK_AC5	BIT(14)
+#define PCIE_INT_D_ASSERT_MASK_AC5	BIT(15)
+
 #define PCIE_ARCACHE_TRC_REG		(PCIE_VENDOR_REGS_OFFSET + 0x50)
 #define PCIE_AWCACHE_TRC_REG		(PCIE_VENDOR_REGS_OFFSET + 0x54)
 #define PCIE_ARUSER_REG			(PCIE_VENDOR_REGS_OFFSET + 0x5C)
 #define PCIE_AWUSER_REG			(PCIE_VENDOR_REGS_OFFSET + 0x60)
 /*
- * AR/AW Cache defaults: Normal memory, Write-Back, Read / Write
+ * AR/AW Cache defauls: Normal memory, Write-Back, Read / Write
  * allocate
  */
 #define ARCACHE_DEFAULT_VALUE		0x3511
@@ -69,89 +83,66 @@ struct armada8k_pcie {
 #define AX_USER_DOMAIN_MASK		0x3
 #define AX_USER_DOMAIN_SHIFT		4
 
-#define to_armada8k_pcie(x)	dev_get_drvdata((x)->dev)
-
-static void armada8k_pcie_disable_phys(struct armada8k_pcie *pcie)
-{
-	int i;
+#define PCIE_STREAM_ID			(PCIE_VENDOR_REGS_OFFSET + 0x64)
+#define STREAM_ID_BUS_BITS		2
+#define STREAM_ID_DEV_BITS		2
+#define STREAM_ID_FUNC_BITS		3
+#define STREAM_ID_PREFIX		0x80
+#define PCIE_STREAM_ID_CFG		(STREAM_ID_PREFIX << 12 | \
+					STREAM_ID_BUS_BITS << 8 | \
+					STREAM_ID_DEV_BITS << 4 | \
+					STREAM_ID_FUNC_BITS)
 
-	for (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {
-		phy_power_off(pcie->phy[i]);
-		phy_exit(pcie->phy[i]);
-	}
-}
+#define to_armada8k_pcie(x)	dev_get_drvdata((x)->dev)
 
-static int armada8k_pcie_enable_phys(struct armada8k_pcie *pcie)
+static int armada8k_pcie_link_up(struct dw_pcie *pci)
 {
-	int ret;
-	int i;
-
-	for (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {
-		ret = phy_init(pcie->phy[i]);
-		if (ret)
-			return ret;
+	u32 reg;
+	u32 mask = PCIE_GLB_STS_RDLH_LINK_UP | PCIE_GLB_STS_PHY_LINK_UP;
 
-		ret = phy_set_mode_ext(pcie->phy[i], PHY_MODE_PCIE,
-				       pcie->phy_count);
-		if (ret) {
-			phy_exit(pcie->phy[i]);
-			return ret;
-		}
+	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_STATUS_REG);
 
-		ret = phy_power_on(pcie->phy[i]);
-		if (ret) {
-			phy_exit(pcie->phy[i]);
-			return ret;
-		}
-	}
+	if ((reg & mask) == mask)
+		return 1;
 
+	dev_dbg(pci->dev, "No link detected (Global-Status: 0x%08x).\n", reg);
 	return 0;
 }
 
-static int armada8k_pcie_setup_phys(struct armada8k_pcie *pcie)
+static u32 ac5_pcie_read_dbi(struct dw_pcie *pci, void __iomem *base,
+				u32 reg, size_t size)
 {
-	struct dw_pcie *pci = pcie->pci;
-	struct device *dev = pci->dev;
-	struct device_node *node = dev->of_node;
-	int ret = 0;
-	int i;
 
-	for (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {
-		pcie->phy[i] = devm_of_phy_get_by_index(dev, node, i);
-		if (IS_ERR(pcie->phy[i])) {
-			if (PTR_ERR(pcie->phy[i]) != -ENODEV)
-				return PTR_ERR(pcie->phy[i]);
-
-			pcie->phy[i] = NULL;
-			continue;
-		}
-
-		pcie->phy_count++;
-	}
+	u32 val;
 
-	/* Old bindings miss the PHY handle, so just warn if there is no PHY */
-	if (!pcie->phy_count)
-		dev_warn(dev, "No available PHY\n");
+	if (base == pci->atu_base)
+		reg |= DEFAULT_DBI_ATU_OFFSET;
 
-	ret = armada8k_pcie_enable_phys(pcie);
-	if (ret)
-		dev_err(dev, "Failed to initialize PHY(s) (%d)\n", ret);
+	/* Handle AC5 ATU access */
+	if ((reg & ~0xfffff) == 0x300000) {
+		reg &= 0xfffff;
+		reg = 0xc000 | (0x200 * (reg >> 9)) | (reg & 0xff);
+	} else if ((reg & 0xfffff000) == PCIE_VENDOR_REGS_OFFSET)
+		reg += 0x8000; /* PCIE_VENDOR_REGS_OFFSET in ac5 is 0x10000 */
+	dw_pcie_read(pci->dbi_base + reg, size, &val);
 
-	return ret;
+	return val;
 }
 
-static int armada8k_pcie_link_up(struct dw_pcie *pci)
+static void ac5_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base,
+				  u32 reg, size_t size, u32 val)
 {
-	u32 reg;
-	u32 mask = PCIE_GLB_STS_RDLH_LINK_UP | PCIE_GLB_STS_PHY_LINK_UP;
+	if (base == pci->atu_base)
+		reg |= DEFAULT_DBI_ATU_OFFSET;
 
-	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_STATUS_REG);
+	/* Handle AC5 ATU access */
+	if ((reg & ~0xfffff) == 0x300000) {
+		reg &= 0xfffff;
+		reg = 0xc000 | (0x200 * (reg >> 9)) | (reg & 0xff);
+	} else if ((reg & 0xfffff000) == PCIE_VENDOR_REGS_OFFSET)
+		reg += 0x8000; /* PCIE_VENDOR_REGS_OFFSET in ac5 is 0x10000 */
 
-	if ((reg & mask) == mask)
-		return 1;
-
-	dev_dbg(pci->dev, "No link detected (Global-Status: 0x%08x).\n", reg);
-	return 0;
+	dw_pcie_write(pci->dbi_base + reg, size, val);
 }
 
 static void armada8k_pcie_establish_link(struct armada8k_pcie *pcie)
@@ -159,6 +150,10 @@ static void armada8k_pcie_establish_link(struct armada8k_pcie *pcie)
 	struct dw_pcie *pci = pcie->pci;
 	u32 reg;
 
+	/* Setup Requester-ID to Stream-ID mapping */
+	if (pcie->pcie_type == MVPCIE_TYPE_A8K)
+		dw_pcie_writel_dbi(pci, PCIE_STREAM_ID, PCIE_STREAM_ID_CFG);
+
 	if (!dw_pcie_link_up(pci)) {
 		/* Disable LTSSM state machine to enable configuration */
 		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
@@ -166,32 +161,46 @@ static void armada8k_pcie_establish_link(struct armada8k_pcie *pcie)
 		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
 	}
 
-	/* Set the device to root complex mode */
-	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
-	reg &= ~(PCIE_DEVICE_TYPE_MASK << PCIE_DEVICE_TYPE_SHIFT);
-	reg |= PCIE_DEVICE_TYPE_RC << PCIE_DEVICE_TYPE_SHIFT;
-	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
+	if (pcie->pcie_type == MVPCIE_TYPE_A8K){
+		/* Set the device to root complex mode */
+		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
+		reg &= ~(PCIE_DEVICE_TYPE_MASK << PCIE_DEVICE_TYPE_SHIFT);
+		reg |= PCIE_DEVICE_TYPE_RC << PCIE_DEVICE_TYPE_SHIFT;
+		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
 
-	/* Set the PCIe master AxCache attributes */
-	dw_pcie_writel_dbi(pci, PCIE_ARCACHE_TRC_REG, ARCACHE_DEFAULT_VALUE);
-	dw_pcie_writel_dbi(pci, PCIE_AWCACHE_TRC_REG, AWCACHE_DEFAULT_VALUE);
+		/* Set the PCIe master AxCache attributes */
+		dw_pcie_writel_dbi(pci, PCIE_ARCACHE_TRC_REG, ARCACHE_DEFAULT_VALUE);
+		dw_pcie_writel_dbi(pci, PCIE_AWCACHE_TRC_REG, AWCACHE_DEFAULT_VALUE);
 
-	/* Set the PCIe master AxDomain attributes */
-	reg = dw_pcie_readl_dbi(pci, PCIE_ARUSER_REG);
-	reg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);
-	reg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;
-	dw_pcie_writel_dbi(pci, PCIE_ARUSER_REG, reg);
+		/* Set the PCIe master AxDomain attributes */
+		reg = dw_pcie_readl_dbi(pci, PCIE_ARUSER_REG);
+		reg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);
+		reg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;
+		dw_pcie_writel_dbi(pci, PCIE_ARUSER_REG, reg);
 
-	reg = dw_pcie_readl_dbi(pci, PCIE_AWUSER_REG);
-	reg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);
-	reg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;
-	dw_pcie_writel_dbi(pci, PCIE_AWUSER_REG, reg);
+		reg = dw_pcie_readl_dbi(pci, PCIE_AWUSER_REG);
+		reg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);
+		reg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;
+		dw_pcie_writel_dbi(pci, PCIE_AWUSER_REG, reg);
+	}
 
 	/* Enable INT A-D interrupts */
-	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG);
-	reg |= PCIE_INT_A_ASSERT_MASK | PCIE_INT_B_ASSERT_MASK |
-	       PCIE_INT_C_ASSERT_MASK | PCIE_INT_D_ASSERT_MASK;
-	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG, reg);
+	if (pcie->pcie_type == MVPCIE_TYPE_AC5) {
+		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG);
+		reg |= PCIE_INT_A_ASSERT_MASK_AC5 | PCIE_INT_B_ASSERT_MASK_AC5 |
+		       PCIE_INT_C_ASSERT_MASK_AC5 | PCIE_INT_D_ASSERT_MASK_AC5;
+		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG, reg);
+	} else {
+		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG);
+		reg |= PCIE_INT_A_ASSERT_MASK | PCIE_INT_B_ASSERT_MASK |
+		       PCIE_INT_C_ASSERT_MASK | PCIE_INT_D_ASSERT_MASK;
+		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG, reg);
+	}
+
+	/* Also enable link down interrupts */
+	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG);
+	reg |= PCIE_INT2_PHY_RST_LINK_DOWN;
+	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG, reg);
 
 	if (!dw_pcie_link_up(pci)) {
 		/* Configuration done. Start LTSSM */
@@ -230,6 +239,36 @@ static irqreturn_t armada8k_pcie_irq_handler(int irq, void *arg)
 	val = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_CAUSE1_REG);
 	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_CAUSE1_REG, val);
 
+	val = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_CAUSE2_REG);
+
+	if (PCIE_INT2_PHY_RST_LINK_DOWN & val) {
+		u32 reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
+		/*
+		 * The link went down. Disable LTSSM immediately. This
+		 * unlocks the root complex config registers. Downstream
+		 * device accesses will return all-Fs without freezing the
+		 * CPU.
+		 */
+		reg &= ~(PCIE_APP_LTSSM_EN);
+		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
+		/*
+		 * Mask link down interrupts. They can be re-enabled once
+		 * the link is retrained.
+		 */
+		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG);
+		reg &= ~PCIE_INT2_PHY_RST_LINK_DOWN;
+		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK2_REG, reg);
+		/*
+		 * At this point a worker thread can be triggered to
+		 * initiate a link retrain. If link retrains were
+		 * possible, that is.
+		 */
+		dev_dbg(pci->dev, "%s: link went down\n", __func__);
+	}
+
+	/* Now clear the second interrupt cause. */
+	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_CAUSE2_REG, val);
+
 	return IRQ_HANDLED;
 }
 
@@ -267,16 +306,111 @@ static int armada8k_add_pcie_port(struct armada8k_pcie *pcie,
 	return 0;
 }
 
-static const struct dw_pcie_ops dw_pcie_ops = {
+static const struct dw_pcie_ops armada8k_dw_pcie_ops = {
 	.link_up = armada8k_pcie_link_up,
 };
 
+static const struct dw_pcie_ops ac5_dw_pcie_ops = {
+	.link_up = armada8k_pcie_link_up,
+	.read_dbi = ac5_pcie_read_dbi,
+	.write_dbi = ac5_pcie_write_dbi,
+};
+
+static int armada8k_phy_config(struct platform_device *pdev,
+			       struct armada8k_pcie *pcie)
+{
+	struct phy *comphy;
+	int err;
+	int i;
+
+	pcie->phy_count = of_count_phandle_with_args(pdev->dev.of_node, "phys",
+					       "#phy-cells");
+	if (pcie->phy_count <= 0)
+		return 0;
+
+	for (i = 0; i < pcie->phy_count; i++) {
+		comphy = devm_of_phy_get_by_index(&pdev->dev,
+						  pdev->dev.of_node, i);
+		if (IS_ERR(comphy)) {
+			dev_err(&pdev->dev, "Failed to get phy %d\n", i);
+			return PTR_ERR(comphy);
+		}
+
+		pcie->comphy[i] = comphy;
+
+		switch (pcie->phy_count) {
+		case PCIE_LNK_X1:
+		case PCIE_LNK_X2:
+		case PCIE_LNK_X4:
+			phy_set_bus_width(comphy, pcie->phy_count);
+			break;
+		default:
+			dev_err(&pdev->dev, "wrong pcie width %d",
+				pcie->phy_count);
+			return -EINVAL;
+		}
+
+		err = phy_set_mode(comphy, PHY_MODE_PCIE);
+		if (err) {
+			dev_err(&pdev->dev, "failed to set comphy\n");
+			return err;
+		}
+
+		err = phy_init(comphy);
+		if (err < 0) {
+			dev_err(&pdev->dev, "phy init failed %d",
+				pcie->phy_count);
+			return err;
+		}
+
+		err = phy_power_on(comphy);
+		if (err < 0) {
+			dev_err(&pdev->dev, "phy init failed %d",
+				pcie->phy_count);
+			phy_exit(comphy);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+/* armada8k_pcie_reset
+ * The function implements the PCIe reset via GPIO.
+ * First, pull down the GPIO used for PCIe reset, and wait 200ms;
+ * Second, set the GPIO output value with setting from DTS, and wait
+ * 200ms for taking effect.
+ * Return: void, always success.
+ */
+static void armada8k_pcie_reset(struct armada8k_pcie *pcie)
+{
+	/* Set the reset gpio to low first */
+	gpiod_direction_output(pcie->reset_gpio, 0);
+	/* After 200ms to reset pcie */
+	mdelay(200);
+	gpiod_direction_output(pcie->reset_gpio,
+			       (pcie->flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+	mdelay(200);
+}
+
+static void armada8k_phy_deconfig(struct armada8k_pcie *pcie)
+{
+	int i;
+
+	for (i = 0; i < pcie->phy_count; i++) {
+		phy_power_off(pcie->comphy[i]);
+		phy_exit(pcie->comphy[i]);
+	}
+}
+
 static int armada8k_pcie_probe(struct platform_device *pdev)
 {
 	struct dw_pcie *pci;
 	struct armada8k_pcie *pcie;
 	struct device *dev = &pdev->dev;
+	struct device_node *dn = pdev->dev.of_node;
 	struct resource *base;
+	int reset_gpio;
 	int ret;
 
 	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
@@ -288,8 +422,16 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	pci->dev = dev;
-	pci->ops = &dw_pcie_ops;
-
+	if (of_device_is_compatible(dn, "marvell,armada8k-pcie")) {
+		pci->ops = &armada8k_dw_pcie_ops;
+		pcie->pcie_type = MVPCIE_TYPE_A8K;
+	}
+	else if (of_device_is_compatible(dn, "marvell,ac5-pcie")) {
+		pci->ops = &ac5_dw_pcie_ops;
+		pcie->pcie_type = MVPCIE_TYPE_AC5;
+	}
+	else
+		dev_err(dev, "couldn't find compatible ops\n");
 	pcie->pci = pci;
 
 	pcie->clk = devm_clk_get(dev, NULL);
@@ -300,58 +442,74 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	pcie->clk_reg = devm_clk_get(dev, "reg");
-	if (pcie->clk_reg == ERR_PTR(-EPROBE_DEFER)) {
-		ret = -EPROBE_DEFER;
-		goto fail;
-	}
-	if (!IS_ERR(pcie->clk_reg)) {
-		ret = clk_prepare_enable(pcie->clk_reg);
-		if (ret)
-			goto fail_clkreg;
-	}
-
 	/* Get the dw-pcie unit configuration/control registers base. */
 	base = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl");
 	pci->dbi_base = devm_pci_remap_cfg_resource(dev, base);
 	if (IS_ERR(pci->dbi_base)) {
 		ret = PTR_ERR(pci->dbi_base);
-		goto fail_clkreg;
+        goto fail;
 	}
 
-	ret = armada8k_pcie_setup_phys(pcie);
-	if (ret)
-		goto fail_clkreg;
+    /* Config reset gpio for pcie if the reset connected to gpio */
+    reset_gpio = of_get_named_gpio_flags(pdev->dev.of_node,
+                        "reset-gpio", 0,
+                        &pcie->flags);
+    if (gpio_is_valid(reset_gpio)) {
+        pcie->reset_gpio = gpio_to_desc(reset_gpio);
+        armada8k_pcie_reset(pcie);
+    }
+
+    ret = armada8k_phy_config(pdev, pcie);
+    if (ret < 0) {
+        dev_err(dev, "PHYs config failed: %d\n", ret);
+        goto fail;
+    }
 
 	platform_set_drvdata(pdev, pcie);
 
 	ret = armada8k_add_pcie_port(pcie, pdev);
 	if (ret)
-		goto disable_phy;
-
+        goto fail_phy;
 	return 0;
 
-disable_phy:
-	armada8k_pcie_disable_phys(pcie);
-fail_clkreg:
-	clk_disable_unprepare(pcie->clk_reg);
+fail_phy:
+    armada8k_phy_deconfig(pcie);
 fail:
-	clk_disable_unprepare(pcie->clk);
-
+    if (!IS_ERR(pcie->clk))
+       clk_disable_unprepare(pcie->clk);
 	return ret;
 }
 
+static int armada8k_pcie_remove(struct platform_device *pdev)
+{
+    struct armada8k_pcie *pcie = platform_get_drvdata(pdev);
+    struct dw_pcie *pci = pcie->pci;
+    struct device *dev = &pdev->dev;
+
+    dw_pcie_host_deinit(&pci->pp);
+
+    armada8k_phy_deconfig(pcie);
+
+    if (!IS_ERR(pcie->clk))
+        clk_disable_unprepare(pcie->clk);
+
+    dev_dbg(dev, "%s\n", __func__);
+
+    return 0;
+}
+
 static const struct of_device_id armada8k_pcie_of_match[] = {
 	{ .compatible = "marvell,armada8k-pcie", },
+	{ .compatible = "marvell,ac5-pcie", },
 	{},
 };
 
 static struct platform_driver armada8k_pcie_driver = {
 	.probe		= armada8k_pcie_probe,
+	.remove		= armada8k_pcie_remove,
 	.driver = {
 		.name	= "armada8k-pcie",
 		.of_match_table = of_match_ptr(armada8k_pcie_of_match),
-		.suppress_bind_attrs = true,
 	},
 };
 builtin_platform_driver(armada8k_pcie_driver);
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 3626758b3..1d670da73 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -20,6 +20,7 @@
 #include <linux/io.h>
 #include <linux/dma-mapping.h>
 
+
 #include "ehci.h"
 
 #define rdl(off)	readl_relaxed(hcd->regs + (off))
@@ -232,7 +233,7 @@ static int ehci_orion_drv_probe(struct platform_device *pdev)
 	 * set. Since shared usb code relies on it, set it here for
 	 * now. Once we have dma capability bindings this can go away.
 	 */
-	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
 	if (err)
 		goto err;
 
@@ -341,7 +342,8 @@ static int ehci_orion_drv_remove(struct platform_device *pdev)
 static const struct of_device_id ehci_orion_dt_ids[] = {
 	{ .compatible = "marvell,orion-ehci", },
 	{ .compatible = "marvell,armada-3700-ehci", },
-	{},
+	{ .compatible = "marvell,ac5-ehci", },
+	{ },
 };
 MODULE_DEVICE_TABLE(of, ehci_orion_dt_ids);
 
